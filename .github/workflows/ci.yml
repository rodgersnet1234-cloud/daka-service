name: Go CI/CD Pipeline

# Trigger workflow on pushes or PRs
on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

jobs:
  build-test-deploy:
    name: Build, Test, and Deploy
    runs-on: ubuntu-latest
    environment:
      name: production

    steps:
      # Step 1: Checkout the code
      - name: Checkout Repository
        uses: actions/checkout@v3

      # Step 2: Setup Go environment
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22'

      # Step 3: Cache Go modules (speeds up builds)
      - name: Cache Go Modules
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      # Step 4: Build Go project
      - name: Build Go Binary
        run: |
          echo "Building Go project..."
          go build -v -o myapp .

      - name: List all files after build
        run: |
          echo "Current directory: $(pwd)"
          find . -name "myapp" -type f -exec ls -lh {} \;

      # Step 5: Run Tests
      - name: Run Go Tests
        run: |
          echo "Running tests..."
          go test -v ./...

      - name: Write SSH key to file
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Copying files
        run : | 
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no myapp ${{ secrets.USER }}@${{ secrets.HOST }}:/opt/daka/tmp/myapp

      # Step: Deploy binary with backup, stop, restart
      - name: Deploy binary safely
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.USER }}@${{ secrets.HOST }} '
            APP_DIR=/opt/daka
            APP_NAME=myapp
            PID_FILE="$APP_DIR/$APP_NAME.pid"
            FULL_PATH="$APP_DIR/$APP_NAME" # Define this so the restart works

            cd $APP_DIR

            # 1. Backup existing binary
            if [ -f "$APP_NAME" ]; then
              i=1
              while [ -f "$APP_NAME.bak$i" ]; do i=$((i+1)); done
              cp "$APP_NAME" "$APP_NAME.bak$i" # Use cp so we can still kill the running one
              echo "Existing binary backed up as $APP_NAME.bak$i"
            fi

            # 2. Kill the old process using PID file (Primary)
            if [ -f "$PID_FILE" ]; then
                OLD_PID=$(cat "$PID_FILE")
                if kill -0 "$OLD_PID" 2>/dev/null; then
                    echo "Stopping process $OLD_PID..."
                    kill "$OLD_PID" && sleep 2
                    kill -9 "$OLD_PID" 2>/dev/null || true
                fi
                rm "$PID_FILE"
            fi

            # 3. Kill-switch (Secondary/Fallback) - Using pgrep to avoid awk errors
            EXTRA_PIDS=$(pgrep -f "$FULL_PATH")
            if [ -n "$EXTRA_PIDS" ]; then
                echo "Cleaning up lingering processes: $EXTRA_PIDS"
                echo "$EXTRA_PIDS" | xargs kill -9 2>/dev/null || true
            fi

            # 4. Deploy new binary
            mv /opt/daka/tmp/myapp "$FULL_PATH"
            chmod +x "$FULL_PATH"

            # 5. Start and save the NEW PID
            echo "Starting $APP_NAME..."
            # Using 'setsid' ensures the process outlives the SSH session
            setsid nohup "$FULL_PATH" > "$FULL_PATH.log" 2>&1 & echo $! > "$PID_FILE"
            
            # 6. Verify
            sleep 2
            FINAL_PID=$(cat "$PID_FILE")
            if kill -0 "$FINAL_PID" 2>/dev/null; then
                echo "Binary started successfully (PID=$FINAL_PID)"
            else
                echo "Binary failed to start! Last 10 lines of log:"
                tail -n 10 "$FULL_PATH.log"
                exit 1
            fi
          '



      # Step 6: Save Binary as Artifact
      # - name: Upload Binary Artifact
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: myapp-binary
      #     path: myapp

      # # Step 7: Deploy to Remote Server
      # # Requires secrets: HOST, USER, SSH_KEY, APP_DIR
      # - name: Deploy to Server via SSH
      #   uses: appleboy/ssh-action@v0.1.7
      #   with:
      #     host: ${{ secrets.HOST }}
      #     username: ${{ secrets.USER }}
      #     key: ${{ secrets.SSH_KEY }}
      #     source: "myapp"
      #     target: "/opt/daka"
      #     port: 22
      #     strip_compnents: 0
      #     overwrite: true
      #     script: |
      #       echo "Upload completed successfully."
